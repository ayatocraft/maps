<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maps</title>
    
    <!-- Leaflet & Tailwind CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- --- CSS (style.css 相当) --- -->
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Noto Sans JP', sans-serif; }
        
        /* 地図コンテナ */
        #map { width: 100%; height: 100%; z-index: 1; }

        /* 現在地マーカー（赤い切り欠き付き三角） */
        .nav-marker-icon {
            transition: transform 0.3s linear;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
        }

        /* ナビゲーション中の案内バー (Green Top Bar) */
        #nav-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #0F9D58; /* Google Maps Green like color */
            color: white;
            z-index: 1000;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: none; /* 初期は非表示 */
            flex-direction: column;
        }

        /* Leafletコントロールの調整（ナビバーとかぶらないように） */
        .leaflet-top {
            top: 120px; /* ナビバーの高さ分ずらす */
            transition: top 0.3s;
        }
        body.navigating .leaflet-top { top: 140px; }

        /* デフォルトのRouting Machineコンテナを隠す（自作UIを使うため） */
        .leaflet-routing-container { display: none !important; }

        /* サイドバー */
        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 350px;
            background: white;
            z-index: 1001;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            padding: 20px;
            overflow-y: auto;
            transform: translateX(0);
            transition: transform 0.3s ease-in-out;
        }
        /* スマホ対応 */
        @media (max-width: 640px) {
            #sidebar { width: 100%; max-width: 100%; }
        }
        
        #sidebar.hidden-side { transform: translateX(-100%); }

        /* 現在地ボタン */
        #center-btn {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 900;
            background: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
            font-size: 1.5rem;
            color: #555;
        }
        #center-btn.active { color: #007bff; }
    </style>
</head>
<body>

    <!-- --- HTML Structure --- -->

    <!-- サイドバー -->
    <div id="sidebar">
        <h1 class="text-xl font-bold mb-4 flex items-center gap-2">
            <i class="fas fa-location-arrow text-blue-500"></i> ナビゲーション
        </h1>
        
        <!-- 地図レイヤー切り替え -->
        <div class="mb-4 bg-gray-100 p-3 rounded">
            <label class="block text-sm font-bold mb-1">地図タイプ</label>
            <div class="flex gap-2">
                <button onclick="setLayer('osm')" class="flex-1 py-1 px-2 bg-white border rounded shadow-sm hover:bg-gray-50 text-sm">標準</button>
                <button onclick="setLayer('satellite')" class="flex-1 py-1 px-2 bg-white border rounded shadow-sm hover:bg-gray-50 text-sm">航空写真</button>
            </div>
        </div>

        <!-- ルート入力 -->
        <div class="space-y-3">
            <div>
                <label class="block text-sm text-gray-600">出発地</label>
                <input type="text" id="start-input" placeholder="現在地 (空白で使用)" class="w-full border p-2 rounded focus:outline-none focus:border-blue-500">
            </div>
            <div>
                <label class="block text-sm text-gray-600">目的地</label>
                <input type="text" id="end-input" placeholder="場所を検索 または 地図をタップ" class="w-full border p-2 rounded focus:outline-none focus:border-blue-500">
            </div>
            
            <div class="flex items-center gap-2">
                <input type="checkbox" id="avoid-highways" class="w-4 h-4">
                <label for="avoid-highways" class="text-sm">高速道路を使わない</label>
            </div>

            <div class="pt-2 grid grid-cols-2 gap-2">
                <button onclick="calculateAndStart(false)" class="bg-blue-600 text-white py-3 rounded shadow hover:bg-blue-700 font-bold">
                    <i class="fas fa-route"></i> ナビ開始
                </button>
                <button onclick="calculateAndStart(true)" class="bg-orange-500 text-white py-3 rounded shadow hover:bg-orange-600 font-bold">
                    <i class="fas fa-play"></i> デモ走行
                </button>
            </div>
            <p class="text-xs text-gray-500 mt-2">※目的地は地図の右クリック(長押し)でも設定できます。</p>
        </div>
    </div>

    <!-- ナビゲーションパネル (案内ビュー) -->
    <div id="nav-panel">
        <div class="flex justify-between items-start">
            <!-- 案内情報 -->
            <div class="flex-1 text-white">
                <div class="flex items-baseline gap-2 mb-1">
                    <span id="nav-turn-icon" class="text-4xl"><i class="fas fa-arrow-up"></i></span>
                    <div>
                        <div id="nav-distance" class="text-3xl font-bold">0 m</div>
                    </div>
                </div>
                <div id="nav-instruction" class="text-lg font-medium leading-tight">案内を開始します</div>
                <div id="nav-total-dist" class="text-sm opacity-80 mt-1">目的地まで: -- km</div>
            </div>

            <!-- 停止ボタン -->
            <button onclick="stopNavigation()" class="ml-4 bg-red-600 text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg hover:bg-red-700 shrink-0">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>

    <!-- 地図 -->
    <div id="map"></div>

    <!-- 現在地センターボタン -->
    <div id="center-btn" onclick="toggleFollowMode()">
        <i class="fas fa-crosshairs"></i>
    </div>


    <!-- --- JavaScript (app.js 相当) --- -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script>
        // --- 設定と初期化 ---
        let map;
        let navMarker;
        let routingControl = null;
        let currentRoute = null;
        let isNavigating = false;
        let isDemoMode = false;
        let isFollowing = true; // 現在地追従モード
        
        // レイヤー定義
        const layers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles © Esri'
            })
        };

        // アイコン定義
        // 赤い切り欠き付き三角形 (SVG)
        const carIconHtml = `
            <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" style="transform-origin: center;">
                <path d="M20 5 L35 35 L20 28 L5 35 Z" fill="#ff3333" stroke="white" stroke-width="2" />
            </svg>
        `;
        const carIcon = L.divIcon({
            className: 'nav-marker-icon',
            html: carIconHtml,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
        });

        const startIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
            iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            shadowSize: [41, 41]
        });
        const endIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            shadowSize: [41, 41]
        });

        // 状態変数
        let myLocation = { lat: 35.681236, lng: 139.767125, heading: 0 }; // デフォルト: 東京駅
        let demoInterval = null;
        let watchId = null;
        let lastSpokenInstruction = "";

        // 初期化
        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([myLocation.lat, myLocation.lng], 15);
            layers.osm.addTo(map);
            L.control.zoom({ position: 'topright' }).addTo(map);

            // 現在地マーカー
            navMarker = L.marker([myLocation.lat, myLocation.lng], { icon: carIcon }).addTo(map);

            // 現在地取得開始
            startGeolocation();

            // マップ右クリック/長押しで目的地設定
            map.on('contextmenu', function(e) {
                document.getElementById('end-input').value = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
                // 逆ジオコーディングができれば地名を入れるが、今回は座標
            });
        }

        function setLayer(type) {
            map.eachLayer(layer => map.removeLayer(layer));
            layers[type].addTo(map);
            // マーカー再描画順序の維持のため
            if(navMarker) navMarker.addTo(map);
            if(routingControl) routingControl.addTo(map);
        }

        // --- GPS / 現在地処理 ---
        function startGeolocation() {
            if ("geolocation" in navigator) {
                watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        // デモ中はGPS更新を無視
                        if (isNavigating && isDemoMode) return;

                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        // headingは移動していないとnullの場合が多い。nullなら計算しないか直前を維持
                        const heading = position.coords.heading || myLocation.heading; 

                        updateMyLocation(lat, lng, heading);

                        // 通常ナビ中のリルート判定
                        if (isNavigating && !isDemoMode && currentRoute) {
                            checkOffRoute(lat, lng);
                        }
                    },
                    (error) => { console.error("GPS Error:", error); },
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
                );
            }
        }

        function updateMyLocation(lat, lng, heading) {
            myLocation = { lat, lng, heading };
            navMarker.setLatLng([lat, lng]);

            // アイコン回転
            const iconEl = navMarker.getElement();
            if (iconEl) {
                const svg = iconEl.querySelector('svg');
                if (svg) svg.style.transform = `rotate(${heading}deg)`;
            }

            // 追従モードならマップセンター移動
            if (isFollowing) {
                map.setView([lat, lng], map.getZoom(), { animate: true });
            }
        }

        function toggleFollowMode() {
            isFollowing = !isFollowing;
            const btn = document.getElementById('center-btn');
            if (isFollowing) {
                btn.classList.add('active');
                map.setView(navMarker.getLatLng());
            } else {
                btn.classList.remove('active');
            }
        }

        // --- ルーティング制御 ---

        // OSRMの日本語マッピングとフォーマット
        function formatDistance(meters) {
            if (meters >= 1000) {
                return (meters / 1000).toFixed(1) + " km";
            }
            // 1km未満は10m刻み
            return (Math.round(meters / 10) * 10) + " m";
        }

        function getTurnText(modifier, type, name) {
            // OSRM modifiers
            const directions = {
                'left': '左方向',
                'right': '右方向',
                'sharp left': '大きく左',
                'sharp right': '大きく右',
                'slight left': '斜め左',
                'slight right': '斜め右',
                'straight': '直進',
                'uturn': 'Uターン'
            };

            let text = "道なり"; // デフォルト

            if (type === 'turn' || type === 'new name') {
                if (directions[modifier]) text = directions[modifier] + "に曲がる";
            } else if (type === 'depart') {
                text = "出発";
            } else if (type === 'arrive') {
                text = "目的地周辺";
            } else if (type === 'roundabout') {
                text = "ロータリー";
            } else if (type === 'fork') {
                text = "分岐を" + (directions[modifier] || "道なり");
            } else if (type === 'on ramp') {
                text = "高速入口";
            } else if (type === 'off ramp') {
                text = "高速出口";
            }

            // 交差点名や道路名がある場合
            if (name && name !== "") {
                if (text.includes("曲がる")) {
                    text = `${name}を${directions[modifier] || modifier}`; // 例: 天神を右方向
                } else {
                    text += ` (${name})`;
                }
            }

            return text;
        }

        function getTurnIcon(modifier) {
            // FontAwesome icon class mapping
            const map = {
                'left': 'fa-arrow-left',
                'right': 'fa-arrow-right',
                'sharp left': 'fa-reply', // 近似
                'sharp right': 'fa-share', // 近似
                'slight left': 'fa-arrow-circle-left', // 近似
                'slight right': 'fa-arrow-circle-right',
                'straight': 'fa-arrow-up',
                'uturn': 'fa-rotate-left'
            };
            return map[modifier] || 'fa-arrow-up';
        }

        async function calculateAndStart(demo) {
            const startInput = document.getElementById('start-input').value;
            const endInput = document.getElementById('end-input').value;
            const avoidHighways = document.getElementById('avoid-highways').checked;

            if (!endInput) {
                alert("目的地を入力してください");
                return;
            }

            let startLatLng = L.latLng(myLocation.lat, myLocation.lng);

            // 出発地のパース (簡易的: 入力があればジオコーディングAPIを呼ぶべきだが、ここでは座標入力または現在地とする)
            // 実際の実装ではここでNominatim APIなどを呼んで地名→座標変換を行う
            // 今回はデモのため「入力がなければ現在地、カンマ区切り数値なら座標」として扱う
            if (startInput && startInput.includes(',')) {
                const parts = startInput.split(',');
                startLatLng = L.latLng(parseFloat(parts[0]), parseFloat(parts[1]));
            }

            // 目的地も同様
            let endLatLng = null;
            if (endInput.includes(',')) {
                const parts = endInput.split(',');
                endLatLng = L.latLng(parseFloat(parts[0]), parseFloat(parts[1]));
                startRouteEngine(startLatLng, endLatLng, avoidHighways, demo);
            } else {
                // 地名検索 (Nominatim)
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(endInput)}`)
                    .then(res => res.json())
                    .then(data => {
                        if (data && data.length > 0) {
                            endLatLng = L.latLng(data[0].lat, data[0].lon);
                            startRouteEngine(startLatLng, endLatLng, avoidHighways, demo);
                        } else {
                            alert("場所が見つかりませんでした");
                        }
                    });
            }
        }

        function startRouteEngine(start, end, avoidHighways, demo) {
            // 既存のルートがあれば削除
            if (routingControl) {
                map.removeControl(routingControl);
                routingControl = null;
            }

            isDemoMode = demo;
            isNavigating = true;

            // UI切り替え
            document.getElementById('sidebar').classList.add('hidden-side');
            document.getElementById('nav-panel').style.display = 'flex';
            document.body.classList.add('navigating');

            // Routing Machine設定
            const routerOptions = {
                waypoints: [start, end],
                router: L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                    profile: 'driving',
                    routingOptions: {
                        exclude: avoidHighways ? ['motorway'] : []
                    }
                }),
                lineOptions: {
                    styles: [{color: '#4285F4', opacity: 0.8, weight: 8}] // Google Maps Blue
                },
                createMarker: function(i, wp, nWps) {
                    if (i === 0) return null; // 出発地マーカーは現在地アイコンとかぶるので非表示
                    return L.marker(wp.latLng, {icon: endIcon});
                },
                addWaypoints: false,
                draggableWaypoints: false,
                fitSelectedRoutes: true,
                showAlternatives: false
            };

            routingControl = L.Routing.control(routerOptions).addTo(map);

            routingControl.on('routesfound', function(e) {
                currentRoute = e.routes[0];
                console.log("Route found:", currentRoute);
                
                // 初回案内更新
                updateNavDisplay(0);

                if (isDemoMode) {
                    startDemoSimulation(currentRoute);
                } else {
                    // 通常ナビ: 現在地を監視して案内を更新するループを開始
                    // (watchPositionが既に動いているので、そちらで判定)
                }
            });
        }

        function stopNavigation() {
            isNavigating = false;
            isDemoMode = false;
            if (demoInterval) clearInterval(demoInterval);
            if (routingControl) {
                map.removeControl(routingControl);
                routingControl = null;
            }
            currentRoute = null;

            // UI戻す
            document.getElementById('sidebar').classList.remove('hidden-side');
            document.getElementById('nav-panel').style.display = 'none';
            document.body.classList.remove('navigating');
            
            // 地図を現在地へ
            map.setView([myLocation.lat, myLocation.lng], 15);
        }

        // --- 案内ロジック ---

        function updateNavDisplay(instructionIndex, distanceToNextStep) {
            if (!currentRoute) return;

            const instructions = currentRoute.instructions;
            if (instructionIndex >= instructions.length) return;

            const instr = instructions[instructionIndex];
            
            // 次の指示までの距離 (デモ用は引数から、通常時は計算が必要だが、OSRMのinstructionsは区間距離を持ってる)
            // リアルタイムナビの場合、instr.distance は「そのステップの全長」なので、
            // 「現在地から次の曲がり角までの距離」を動的に計算する必要がある。
            // ここでは簡易的に表示用ロジックを組みます。

            const text = getTurnText(instr.modifier, instr.type, instr.text);
            const iconClass = getTurnIcon(instr.modifier);
            
            // 表示更新
            document.getElementById('nav-instruction').textContent = text;
            document.getElementById('nav-turn-icon').innerHTML = `<i class="fas ${iconClass}"></i>`;
            
            // 距離表示 (リアルタイム計算された値を使用)
            if (distanceToNextStep !== undefined) {
                 document.getElementById('nav-distance').textContent = formatDistance(distanceToNextStep);
            } else {
                 document.getElementById('nav-distance').textContent = formatDistance(instr.distance);
            }

            // 目的地までの残り距離
            const totalDist = currentRoute.summary.totalDistance; // 全長
            // 簡易的に全長を表示しているが、本来は残り距離を計算すべき
            document.getElementById('nav-total-dist').textContent = "全長: " + (totalDist/1000).toFixed(1) + " km";

            // 音声案内 (新しい指示になったら喋る)
            const speakText = `およそ、${formatDistance(distanceToNextStep || instr.distance)}先、${text}です。`;
            // 同じ指示を連呼しない制御
            const uniqueKey = instructionIndex + "_" + Math.floor((distanceToNextStep || 0) / 100); // 100m単位で変化あれば
            
            // 単純化: インデックスが変わった時、または距離が特定のタイミング(1km, 500m, 300m, 100m)を切った時に喋る
            // ここではデモ用に「指示が変わった時」のみにします
            if (lastSpokenInstruction !== instructionIndex) {
                speak(speakText);
                lastSpokenInstruction = instructionIndex;
            }
        }

        // --- デモ走行ロジック ---
        function startDemoSimulation(route) {
            const coords = route.coordinates; // 全座標配列
            let i = 0;
            
            // OSRMのinstructionはcoordIndexを持っている
            // 現在の座標インデックスに対応する案内を探す関数
            function getCurrentInstructionIndex(coordIdx) {
                // instructions配列を逆順に見て、現在のcoordIdx以下の最大のindexを持つものを探す
                for (let k = route.instructions.length - 1; k >= 0; k--) {
                    if (route.instructions[k].index <= coordIdx) {
                        return k;
                    }
                }
                return 0;
            }

            // 次の案内ポイント（曲がり角）までの距離を計算
            function getDistToNextTurn(currCoordIdx, nextInstrIdx) {
                if (nextInstrIdx >= route.instructions.length) return 0;
                const nextTurnCoordIdx = route.instructions[nextInstrIdx].index;
                const nextTurnCoord = route.coordinates[nextTurnCoordIdx];
                const currCoord = route.coordinates[currCoordIdx];
                return map.distance(currCoord, nextTurnCoord);
            }

            demoInterval = setInterval(() => {
                if (i >= coords.length - 1) {
                    clearInterval(demoInterval);
                    speak("目的地に到着しました");
                    alert("到着しました");
                    stopNavigation();
                    return;
                }

                const curr = coords[i];
                const next = coords[i+1];
                
                // 角度計算
                const heading = calculateHeading(curr.lat, curr.lng, next.lat, next.lng);
                
                updateMyLocation(curr.lat, curr.lng, heading);

                // 案内更新判定
                // 現在のcoord indexに対応するInstructionを探す
                // 注意: OSRMのinstructions[k]は、「そこから始まる区間」の説明。
                // なので、「次の案内」は k+1 の内容を表示し、距離は k+1 の地点までの距離を表示するのが自然。
                
                const currentInstrIdx = getCurrentInstructionIndex(i);
                const nextInstrIdx = currentInstrIdx + 1;

                if (nextInstrIdx < route.instructions.length) {
                    const distToTurn = getDistToNextTurn(i, nextInstrIdx);
                    // UIには「次のアクション」を表示したい
                    // instructions[nextInstrIdx] が「右折」なら、「300m先 右折」と出したい
                    
                    // updateNavDisplayのロジックを少し調整：引数にInstructionオブジェクトを直接渡す設計の方が良いが、
                    // 既存関数に合わせてIndexを渡す。ただし表示内容は nextInstrIdx のものを使うようにハックする。
                    
                    // ここではシンプルに: 
                    // 現在走っている区間 = instructions[currentInstrIdx]
                    // その区間の終わりにあるアクション = instructions[nextInstrIdx] の modifier/text
                    // 距離 = 現在地から instructions[nextInstrIdx].index の座標までの距離
                    
                    const nextInstr = route.instructions[nextInstrIdx];
                    const text = getTurnText(nextInstr.modifier, nextInstr.type, nextInstr.text);
                    
                    document.getElementById('nav-instruction').textContent = text;
                    document.getElementById('nav-turn-icon').innerHTML = `<i class="fas ${getTurnIcon(nextInstr.modifier)}"></i>`;
                    document.getElementById('nav-distance').textContent = formatDistance(distToTurn);

                    // 音声トリガー (300m, 100m, 直前)
                    if ((distToTurn < 310 && distToTurn > 290) || (distToTurn < 110 && distToTurn > 90)) {
                         // 重複防止フラグなどが必要だが省略
                         if (lastSpokenInstruction !== `dist_${Math.floor(distToTurn)}`) {
                             speak(`およそ${formatDistance(distToTurn)}先、${text}です`);
                             lastSpokenInstruction = `dist_${Math.floor(distToTurn)}`;
                         }
                    }
                }

                i++; // 進む
            }, 50); // 更新速度 (ms)
        }

        // --- ヘルパー関数 ---

        function calculateHeading(lat1, lng1, lat2, lng2) {
            const y = Math.sin(lng2 - lng1) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) -
                    Math.sin(lat1) * Math.cos(lat2) * Math.cos(lng2 - lng1);
            const brng = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
            return brng;
        }

        function speak(text) {
            if ('speechSynthesis' in window) {
                // キャンセルしてから次を話す
                // window.speechSynthesis.cancel(); 
                const uttr = new SpeechSynthesisUtterance(text);
                uttr.lang = 'ja-JP';
                uttr.rate = 1.0;
                window.speechSynthesis.speak(uttr);
            }
        }

        // リルート判定 (通常走行時)
        function checkOffRoute(lat, lng) {
            if (!currentRoute) return;
            
            // 現在地とルート上の最も近い点との距離を計算
            // Leaflet Routing Machineは内部で持っているが、APIアクセスが難しいため
            // 簡易的に「Start地点を現在地に更新」するアプローチをとる
            // 本格的には L.GeometryUtil.distanceToLayer などが必要
            
            // ここでは簡易実装: 
            // 実際はGPSの位置が更新されるたびに、RoutingControlのwaypoints[0]を更新すれば
            // Routing Machineが勝手にリルート計算してくれる
            
            const startWp = routingControl.getWaypoints()[0];
            const dist = map.distance([lat, lng], startWp.latLng);
            
            // 50m以上移動したら始点を更新して再計算（頻繁すぎると重いので調整が必要）
            if (dist > 50) {
                const endWp = routingControl.getWaypoints()[1];
                routingControl.setWaypoints([
                    L.latLng(lat, lng),
                    endWp.latLng
                ]);
            }
        }

        // 実行開始
        window.onload = initMap;

    </script>
</body>
</html>
