<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ãƒãƒƒãƒ—</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
/* å…±é€šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
html { height: 100%; }
body {
  height: 100vh; 
  margin: 0; 
  font-family: sans-serif;
  display: flex; 
}
/* ã‚µã‚¤ãƒ‰ãƒãƒ¼å†…ã®ãƒœã‚¿ãƒ³ãƒ»å…¥åŠ›æ¬„ */
input, select, button {
  width: 100%; 
  margin-bottom: 10px; 
  padding: 8px; 
  font-size: 16px;
  box-sizing: border-box; 
}

#sidebar {
  width: 300px; 
  max-width: 80%;
  height: 100%;
  background: #f9f9f9;
  padding: 10px;
  box-shadow: 2px 0 5px rgba(0,0,0,0.3);
  overflow-y: auto;
  z-index: 1000;
  box-sizing: border-box; 
}
#map-container {
  flex: 1; 
  height: 100%;
  position: relative; 
}
#map {
  height: 100%;
  width: 100%;
}

/* ãƒˆãƒƒãƒ—ãƒãƒ¼ (ç·‘) */
#topbar {
  position: absolute; 
  top: 10px;
  left: 10px; 
  right: 10px; 
  height: auto; 
  background: green; 
  color: white; 
  display: none; 
  flex-direction: row; 
  align-items: center; 
  justify-content: space-between; 
  padding: 10px 15px; 
  box-sizing: border-box; 
  z-index: 1001; /* Zoomãƒœã‚¿ãƒ³ã‚ˆã‚Šä¸Š */
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  flex-wrap: wrap; 
}
#topbar span#nav-next {
  font-size: 20px; 
  font-weight: bold;
}
#topbar span#nav-remaining {
  font-size: 16px; 
  font-weight: normal;
  color: #f0f0f0; 
}
#topbar button { 
  position: static; 
  background: #f44336; 
  color: white; 
  border: none; 
  padding: 5px 10px; 
  font-size: 14px;  
  font-weight: bold;
  cursor: pointer; 
  border-radius: 5px; 
  width: auto; 
  margin-bottom: 0;
}

/* ç¾åœ¨åœ°ã«æˆ»ã‚‹ãƒœã‚¿ãƒ³ */
#recenter-btn {
  position: absolute;
  bottom: 20px;
  right: 20px;
  width: 50px;
  height: 50px;
  font-size: 24px;
  border-radius: 50%; 
  border: none;
  background-color: white;
  color: #333;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  cursor: pointer;
  z-index: 900; 
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0; 
  margin-bottom: 0; 
}
#recenter-btn:hover {
  background-color: #f4f4f4;
}

#info { font-size: 14px; }

/* ä¸‰è§’ãƒãƒ¼ã‚¯ï¼ˆã‚«ãƒ¼ãƒŠãƒ“é¢¨åˆ‡ã‚Šæ¬ ãï¼‰ */
.triangle div {
  width: 0; 
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 24px solid red; 
  transform-origin: bottom center;
  clip-path: polygon(50% 0%, 100% 100%, 70% 100%, 50% 70%, 30% 100%, 0% 100%);
}

#streetview {
  position: absolute; 
  top: 0; 
  left: 0; 
  width: 100%; 
  height: 100%; 
  display: none; 
  z-index: 2000; 
}
</style>
</head>
<body>

<div id="sidebar">
  <h3>ãƒ«ãƒ¼ãƒˆæ¤œç´¢</h3>
  <input type="text" id="start" placeholder="å‡ºç™ºåœ°ï¼ˆç©ºæ¬„ã§ç¾åœ¨åœ°ï¼‰">
  <input type="text" id="end" placeholder="ç›®çš„åœ°">
  <select id="mode">
    <option value="driving">è»Š</option>
    <option value="walking">å¾’æ­©</option>
    <option value="cycling">è‡ªè»¢è»Š</option>
  </select>
  <select id="maptype">
    <option value="street">æ¨™æº–åœ°å›³</option>
    <option value="satellite">èˆªç©ºå†™çœŸ</option>
  </select>
  <button onclick="switchMapLayer()">ãƒãƒƒãƒ—åˆ‡æ›¿</button>
  <button onclick="startNormalNav()">é€šå¸¸ãƒŠãƒ“é–‹å§‹</button>
  <button onclick="startDemoNav()">ãƒ‡ãƒ¢èµ°è¡Œé–‹å§‹</button>
  <button onclick="showStreetView()">ã‚¹ãƒˆãƒªãƒ¼ãƒˆãƒ“ãƒ¥ãƒ¼</button>
  <div id="info"></div>
</div>

<div id="map-container">
  <div id="topbar">
    <div>
      <span id="nav-next">æ¬¡ã®æ›²ãŒã‚Šè§’: -</span><br>
      <span id="nav-remaining">æ®‹ã‚Š: -</span>
    </div>
    <button onclick="stopNav()">åœæ­¢</button>
  </div>
  
  <div id="map"></div>
  
  <button id="recenter-btn" onclick="recenterMap()">ğŸ“</button>
  
  <div id="streetview"></div>
</div>


<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://rawcdn.githack.com/bbecquet/Leaflet.RotatedMarker/master/leaflet.rotatedMarker.js"></script>

<script>
let map = L.map('map',{zoomControl:true}).setView([35.68,139.76], 13);
let baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'Â©OSM'}).addTo(map);
let satLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{subdomains:['mt0','mt1','mt2','mt3']});
let destMarker, routeLine, navMarker;
let routeCoords=[], maneuvers=[], navIndex=0;
let navInterval = null; 
let startCoord=null, destCoord=null;
let useGPS = true; 
const speech=window.speechSynthesis;
let isRerouting = false;

// ç¾åœ¨åœ°è£œæ­£ã¨ãƒãƒ¼ã‚«ãƒ¼å›è»¢
function watchCurrentPosition(){
Â  if(navigator.geolocation){
Â  Â  navigator.geolocation.watchPosition(pos=>{
Â  
Â  Â  Â  const latlng=[pos.coords.latitude, pos.coords.longitude];
      const heading = pos.coords.heading; 
Â  Â  Â  
Â  Â  Â  if(!navMarker) {
Â  Â  Â  Â  navMarker = L.marker(latlng, {
          icon: L.divIcon({className:'triangle', html:'<div></div>'}),
Â  Â  Â  Â  Â  rotationAngle: 0
Â  Â  Â  Â  }).addTo(map);
        
        if(!startCoord) {
            map.setView(latlng, 16);
            startCoord = latlng; 
        }
Â  Â  Â  }
      
Â  Â  Â  if(useGPS) {
        navMarker.setLatLng(latlng);
        if (heading !== null && heading !== undefined) {
          navMarker.setRotationAngle(heading);
        }
      }
Â  Â  Â  
Â  Â  Â  startCoord=latlng; 
Â  Â  }, err=>console.warn("ä½ç½®æƒ…å ±å–å¾—å¤±æ•—:",err), {enableHighAccuracy:true, maximumAge:1000, timeout:5000});
Â  }
}
watchCurrentPosition(); 

// ç¾åœ¨åœ°ã«æˆ»ã‚‹é–¢æ•°
function recenterMap() {
  if (startCoord) { 
    map.setView(startCoord, 16); 
    if (navMarker) {
      navMarker.setLatLng(startCoord); 
    }
    if (navInterval) { 
      stopNav(); 
    } else {
      useGPS = true; // GPSè¿½å¾“ãƒ¢ãƒ¼ãƒ‰ON
    }
  } else {
    alert("ç¾åœ¨åœ°ãŒã¾ã å–å¾—ã§ãã¦ã„ã¾ã›ã‚“ã€‚");
  }
}

// ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
async function geocode(query){
Â  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
Â  const data = await res.json();
Â  if(data.length===0) throw "ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“";
Â  return {lat:parseFloat(data[0].lat), lng:parseFloat(data[0].lon), name:data[0].display_name};
}

// ç›®çš„åœ°æ¤œç´¢
async function searchDestination(){
  // â˜…ä¿®æ­£: ã‚¸ã‚ªã‚³ãƒ¼ãƒ‰å¤±æ•—æ™‚ã«ã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒ
  try {
    const endAddr=document.getElementById('end').value;
Â    if(!endAddr) { alert("ç›®çš„åœ°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return false; } // â˜…ä¿®æ­£
Â    const dest=await geocode(endAddr);
Â    destCoord=[dest.lat,dest.lng];
Â    if(destMarker) map.removeLayer(destMarker);
Â    destMarker=L.marker(destCoord).addTo(map).bindPopup(dest.name).openPopup();
Â    map.setView(destCoord,16);
Â    document.getElementById('info').innerText=`æ¤œç´¢å®Œäº†: ${dest.name}`;
Â    speak(`ç›®çš„åœ°ã¯${dest.name}ã§ã™`);
Â    if(routeLine) map.removeLayer(routeLine);
    return true; // â˜…ä¿®æ­£: æˆåŠŸ
  } catch(err) {
    alert("ç›®çš„åœ°ã®æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err);
    return false; // â˜…ä¿®æ­£: å¤±æ•—
  }
}

// ãƒãƒƒãƒ—åˆ‡æ›¿
function switchMapLayer(){
Â  const type=document.getElementById('maptype').value;
Â  if(type==='satellite'){ map.addLayer(satLayer); map.removeLayer(baseLayer); }
Â  else{ map.addLayer(baseLayer); map.removeLayer(satLayer); }
}

// ã‚¹ãƒˆãƒªãƒ¼ãƒˆãƒ“ãƒ¥ãƒ¼
function showStreetView(){
Â  if(!destCoord) return alert("ç›®çš„åœ°ã‚’å…ˆã«æ¤œç´¢ã—ã¦ãã ã•ã„");
Â  document.getElementById('streetview').style.display='block';
Â  document.getElementById('streetview').innerHTML=`<iframe width="100%" height="100%" frameborder="0" style="border:0"
Â  src="https://www.google.com/maps/embed/v1/streetview?location=$${destCoord[0]},${destCoord[1]}&layer=c&cbll=${destCoord[0]},${destCoord[1]}&cbp=12,210,0,0,0" allowfullscreen></iframe>`;
}


// ã‚¹ãƒãƒ›ç”¨éŸ³å£°ã®åˆæœŸåŒ–
function primeSpeech() {
  if (speech.speaking) return; 
  speech.cancel(); 
  const u = new SpeechSynthesisUtterance(' '); 
  u.volume = 0; 
  u.lang = 'ja-JP';
  speech.speak(u);
}

// ãƒŠãƒ“é–‹å§‹
async function startNormalNav(){
  primeSpeech(); 
Â  useGPS=true; 
  const success = await searchDestination(); // â˜…ä¿®æ­£
  if (!success) return; // â˜…ä¿®æ­£

Â  const startAddr=document.getElementById('start').value;
Â  if(startAddr){ 
    try { // â˜…ä¿®æ­£: å‡ºç™ºåœ°ã®ã‚¸ã‚ªã‚³ãƒ¼ãƒ‰å¤±æ•—ã‚’ã‚­ãƒ£ãƒƒãƒ
      const s=await geocode(startAddr); 
      startCoord=[s.lat,s.lng]; 
    } catch(err) {
      alert("å‡ºç™ºåœ°ã®æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err);
      return;
    }
  }
Â  else if (!startCoord) { 
     alert("ç¾åœ¨åœ°ãŒå–å¾—ã§ãã¦ã„ã¾ã›ã‚“ã€‚å°‘ã—å¾…ã¤ã‹å‡ºç™ºåœ°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
     return;
  }
Â  await startNav(startCoord,destCoord,true); 
}

async function startDemoNav(){
  primeSpeech(); 
Â  useGPS=false; 
  const success = await searchDestination(); // â˜…ä¿®æ­£
  if (!success) return; // â˜…ä¿®æ­£
  
Â  const startAddr=document.getElementById('start').value;
Â  let start;
Â  if(startAddr){ 
    try { // â˜…ä¿®æ­£: å‡ºç™ºåœ°ã®ã‚¸ã‚ªã‚³ãƒ¼ãƒ‰å¤±æ•—ã‚’ã‚­ãƒ£ãƒƒãƒ
      const s=await geocode(startAddr); 
      start=[s.lat,s.lng]; 
    } catch(err) {
      alert("å‡ºç™ºåœ°ã®æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err);
      return;
    }
  }
Â  else start=startCoord || [map.getCenter().lat,map.getCenter().lng]; 
Â  await startNav(start,destCoord,false); 
}

// å…±é€šãƒŠãƒ“
async function startNav(start,end,isReal){
  if(navInterval) clearInterval(navInterval);
  navInterval = null;

Â  document.getElementById('sidebar').style.display='none';
Â  document.getElementById('topbar').style.display='flex';
  
  setTimeout(() => map.invalidateSize(), 100);

Â  const mode=document.getElementById('mode').value;
Â  const url=`https://router.project-osrm.org/route/v1/${mode}/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson&steps=true&intersections=true`;
  
  let data;
  try {
    const res=await fetch(url);
Â    data=await res.json();
Â    if(!data.routes || data.routes.length===0 || data.code !== 'Ok'){ // â˜…ä¿®æ­£: OSRMã® `code` ã‚‚ç¢ºèª
      // â˜…ä¿®æ­£: ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å…·ä½“çš„ã«
      console.warn("OSRMã‹ã‚‰ãƒ«ãƒ¼ãƒˆãŒè¿”ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ:", data);
      alert("ãƒ«ãƒ¼ãƒˆãŒå–å¾—ã§ãã¾ã›ã‚“ã€‚å‡ºç™ºåœ°ã¾ãŸã¯ç›®çš„åœ°ãŒé“è·¯ã‹ã‚‰é›¢ã‚Œã™ãã¦ã„ãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚"); 
      stopNav(); 
      return; 
    }
  } catch(err) {
    // â˜…ä¿®æ­£: ã‚¢ãƒ©ãƒ¼ãƒˆã¨ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ã‚’å…·ä½“çš„ã«
    console.error("ãƒ«ãƒ¼ãƒˆæ¤œç´¢ã‚¨ãƒ©ãƒ¼:", err);
    alert("ãƒ«ãƒ¼ãƒˆæ¤œç´¢ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã™ã‚‹ã‹ã€ã‚µãƒ¼ãƒãƒ¼ãŒãƒ€ã‚¦ãƒ³ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
    stopNav();
    return;
  }

Â  routeCoords=[]; maneuvers=[];
Â  data.routes[0].legs[0].steps.forEach(step=>{
    const maneuverLoc = step.maneuver.location;
Â  Â  maneuvers.push({
Â  Â  Â  loc:[maneuverLoc[1], maneuverLoc[0]], 
      type: step.maneuver.type,
      modifier: step.maneuver.modifier,
      name: step.name, 
      destinations: step.destinations, 
      exits: step.exits, 
      classes: (step.intersections[0] && step.intersections[0].classes) ? step.intersections[0].classes : [] 
Â  Â  });
Â  Â  step.geometry.coordinates.forEach(c=>routeCoords.push([c[1],c[0]]));
Â  });

Â  if(routeLine) map.removeLayer(routeLine);
Â  routeLine=L.polyline(routeCoords,{color:'blue',weight:6}).addTo(map);

Â  if(navMarker){
    navMarker.setLatLng(start);
  } else {
     navMarker=L.marker(start,{
Â  Â  Â  icon:L.divIcon({className:'triangle', html:'<div></div>'}),
Â  Â  Â  rotationAngle:0
Â  Â  }).addTo(map);
  }

Â  navIndex=0;
Â  let lastSpokenStep=null;
  let maneuverIndex = 0; 
  isRerouting = false; 

Â  navInterval = setInterval(async () => {
    if (isReal) {
        // --- ãƒªã‚¢ãƒ«ãƒŠãƒ“ï¼†ãƒªãƒ«ãƒ¼ãƒˆ ---
        if (isRerouting) return; 
        const pos = startCoord; 
        if (!pos || !routeCoords || routeCoords.length === 0) return;

        // ãƒ«ãƒ¼ãƒˆé€¸è„±åˆ¤å®š
        const closestIdx = findClosestPointOnRoute(pos, routeCoords);
        if (closestIdx === null) return; 
        const closestPoint = routeCoords[closestIdx];
        const distanceOffRoute = getDistance(pos, closestPoint);
        const rerouteTolerance = 75; // 75m
        if (distanceOffRoute > rerouteTolerance) {
            isRerouting = true; 
            speak("ãƒ«ãƒ¼ãƒˆã‚’å¤–ã‚Œã¾ã—ãŸã€‚å†æ¤œç´¢ã—ã¾ã™ã€‚");
            await startNav(startCoord, destCoord, true); 
            return; 
        }

        // --- ãƒªã‚¢ãƒ«ãƒŠãƒ“æ¡ˆå†…ãƒ­ã‚¸ãƒƒã‚¯ ---
        const nextManeuver = maneuvers[maneuverIndex];
        if (nextManeuver) {
            const distToManeuver = getDistance(pos, nextManeuver.loc); 
            const distStr = distToManeuver < 1000 ?
                `${Math.round(distToManeuver)} m` :
                `${(distToManeuver / 1000).toFixed(1)} km`;
            
            const instruction = getInstructionText(nextManeuver);
            document.getElementById('nav-next').innerText = `æ¬¡: ${distStr} - ${instruction}`;

            // æ¡ˆå†…å®Ÿè¡Œ (ãƒ‡ãƒ¢ã‚ˆã‚Šåºƒã„è·é›¢ã§åå¿œ)
            if (distToManeuver < 40) { 
                if (lastSpokenStep !== nextManeuver && speech) {
                    speak(instruction); // â˜…ä¿®æ­£: speaké–¢æ•°ã‚’ä½¿ã†
                    lastSpokenStep = nextManeuver;
                }
                maneuverIndex++; 
            }
        } else {
            document.getElementById('nav-next').innerText = `ã¾ã‚‚ãªãåˆ°ç€`;
        }

        // æ®‹ã‚Šè·é›¢ã¨åˆ°ç€åˆ¤å®š
        const remainingDist = calculateRemainingDistance(closestIdx, routeCoords);
        document.getElementById('nav-remaining').innerText = `æ®‹ã‚Š: ${remainingDist}`;
        if (getDistance(pos, destCoord) < 50) { 
             stopNav();
             speak("ç›®çš„åœ°ã«åˆ°ç€ã—ã¾ã—ãŸ");
             alert("ç›®çš„åœ°ã«åˆ°ç€ã—ã¾ã—ãŸ");
             return;
        }
        return; 
    }

    // --- ãƒ‡ãƒ¢èµ°è¡Œãƒ­ã‚¸ãƒƒã‚¯ ---
Â  Â  if(navIndex>=routeCoords.length){
Â  Â  Â  stopNav();
Â  Â  Â  speak("ç›®çš„åœ°ã«åˆ°ç€ã—ã¾ã—ãŸ");
Â  Â  Â  alert("ç›®çš„åœ°ã«åˆ°ç€ã—ã¾ã—ãŸ");
Â  Â  Â  return;
Â  Â  }

Â  Â  const pos=routeCoords[navIndex];
Â  Â  const nextPos=routeCoords[Math.min(navIndex+1,routeCoords.length-1)];
Â  Â  navMarker.setLatLng(pos); 
    
Â  Â  const angle = Math.atan2(nextPos[1] - pos[1], nextPos[0] - pos[0]) * 180 / Math.PI;
Â  Â  navMarker.setRotationAngle(angle);
    
Â  Â  if(!isReal) map.setView(pos, 17, {animate:true}); 

    // ãƒ‡ãƒ¢èµ°è¡Œã®æ¡ˆå†…
    const nextManeuver = maneuvers[maneuverIndex];
    if (nextManeuver) {
        const distToManeuver = getDistance(pos, nextManeuver.loc); 
        const distStr = distToManeuver < 1000 ?
            `${Math.round(distToManeuver)} m` :
            `${(distToManeuver / 1000).toFixed(1)} km`;
        
        const instruction = getInstructionText(nextManeuver);
        document.getElementById('nav-next').innerText = `æ¬¡: ${distStr} - ${instruction}`;

        if (distToManeuver < 20) { 
            if (lastSpokenStep !== nextManeuver && speech) {
                speak(instruction); // â˜…ä¿®æ­£: speaké–¢æ•°ã‚’ä½¿ã†
                lastSpokenStep = nextManeuver;
            }
            maneuverIndex++; 
        }
    } else {
        document.getElementById('nav-next').innerText = `ã¾ã‚‚ãªãåˆ°ç€`;
    }

Â  Â  const remainingDist=calculateRemainingDistance(navIndex,routeCoords);
Â  Â  document.getElementById('nav-remaining').innerText=`æ®‹ã‚Š: ${remainingDist}`;

Â  Â  navIndex++;
Â  }, 500); 
}

// åœæ­¢ãƒœã‚¿ãƒ³
function stopNav(){
Â  if(navInterval) clearInterval(navInterval);
  navInterval = null; 

Â  document.getElementById('sidebar').style.display='block';
Â  document.getElementById('topbar').style.display='none';
  
  setTimeout(() => map.invalidateSize(), 100);

Â  if(routeLine) map.removeLayer(routeLine);
Â  routeLine=null;
Â  routeCoords=[]; maneuvers=[]; navIndex=0;
Â  document.getElementById('streetview').style.display='none';
  document.getElementById('streetview').innerHTML = '';
  
  useGPS = true; 
  isRerouting = false; 
}

// è·é›¢è¨ˆç®—
function getDistance(a,b){
Â  const R=6371000; // ãƒ¡ãƒ¼ãƒˆãƒ«
Â  const dLat=(b[0]-a[0])*Math.PI/180;
Â  const dLon=(b[1]-a[1])*Math.PI/180;
Â  const lat1=a[0]*Math.PI/180, lat2=b[0]*Math.PI/180;
Â  const d=Math.sin(dLat/2)**2 + Math.sin(dLon/2)**2*Math.cos(lat1)*Math.cos(lat2);
Â  return 2*R*Math.atan2(Math.sqrt(d),Math.sqrt(1-d));
}

// æ®‹ã‚Šè·é›¢
function calculateRemainingDistance(idx,coords){
  if (idx === null) return '- km'; // â˜…ä¿®æ­£
Â  let sum=0;
Â  for(let i=idx;i<coords.length-1;i++){
Â  Â  sum+=getDistance(coords[i],coords[i+1]);
Â  }
Â  if(sum<1000) return `${Math.round(sum)} m`;
Â  else return `${(sum/1000).toFixed(1)} km`;
}

// ãƒ«ãƒ¼ãƒˆä¸Šã®æœ€å¯„ã‚Šç‚¹ã‚’æ¢ã™
function findClosestPointOnRoute(pos, coords) {
    if (!coords || coords.length === 0) return null; 
    let closestDist = Infinity;
    let closestIdx = 0;
    for (let i = 0; i < coords.length; i++) {
        const dist = getDistance(pos, coords[i]);
        if (dist < closestDist) {
            closestDist = dist;
            closestIdx = i;
        }
    }
    return closestIdx;
}

// OSRMæƒ…å ±ã‹ã‚‰é«˜æ©Ÿèƒ½ãªæ—¥æœ¬èªæ¡ˆå†…ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
function getInstructionText(maneuver) {
  const type = maneuver.type;
  const modifier = maneuver.modifier;
  const name = maneuver.name || ''; // é“è·¯/äº¤å·®ç‚¹/æ–½è¨­å
  const destinations = (maneuver.destinations || '').split(',')[0]; 
  const exits = maneuver.exits; // å‡ºå£ç•ªå·
  const classes = maneuver.classes || []; // æ–½è¨­æƒ…å ±

  // 1. ç‰¹æ®Šæ–½è¨­ï¼ˆæ–™é‡‘æ‰€ã€SA/PAï¼‰
  if (classes.includes('toll_booth')) {
    return (name || 'æ–™é‡‘æ‰€') + ' ã‚’é€šéã—ã¾ã™';
  }
  if (type === 'service' || classes.includes('service_area') || classes.includes('rest_area')) {
     return (name || 'ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒªã‚¢') + ' ã«å…¥ã‚Šã¾ã™';
  }
  // PA/SAã¸ã®ã‚ªãƒ•ãƒ©ãƒ³ãƒ— (åå‰ã§åˆ¤å®š)
  if (type === 'off ramp' && (name.toUpperCase().includes('PA') || name.toUpperCase().includes('SA'))) {
     return name + ' ã«å…¥ã‚Šã¾ã™';
  }
  
  // 2. OSRMã®æ“èˆµã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ã¦æ¡ˆå†…ã‚’ç”Ÿæˆ
  switch (type) {
    case 'depart':
      return 'å‡ºç™ºã—ã¾ã™';

    // é«˜é€Ÿå…¥å£ (ä¾‹: å°å€‰å—ICã‹ã‚‰é«˜é€Ÿé“è·¯ã«å…¥ã‚‹)
    case 'on ramp':
      return (name || 'ãƒ©ãƒ³ãƒ—') + ' ã‹ã‚‰é«˜é€Ÿé“è·¯ã«å…¥ã‚Šã¾ã™';

    // é«˜é€Ÿå‡ºå£ (ä¾‹: å…«å¹¡ICã§é«˜é€Ÿé“è·¯ã‚’é™ã‚Šã‚‹)
    case 'off ramp':
      let exitText = (exits ? ` (å‡ºå£ ${exits})` : '');
      return (destinations ? destinations + ' æ–¹é¢ã€' : '') + (name || 'å‡ºå£') + exitText + ' ã§é«˜é€Ÿé“è·¯ã‚’é™ã‚Šã¾ã™';

    // é«˜é€Ÿåˆ†å² (ä¾‹: åŒ—ä¹å·JCTã§åˆ†å²ã‚’å·¦)
    case 'fork':
      // modifierãŒç„¡ã„forkã¯ã€Œé“ãªã‚Šã€
      if (!modifier) return (name ? name + ' ã‚’ ' : '') + 'é“ãªã‚Šã«é€²ã¿ã¾ã™';
      return (name ? name + ' ã§ ' : '') + (destinations ? destinations + ' æ–¹é¢ã€' : '') + getDirectionText(modifier) + ' æ–¹å‘ã§ã™';

    // é«˜é€Ÿåˆæµ
    case 'merge':
       return (destinations ? destinations + ' æ–¹é¢ã€' : '') + (name ? name + ' ã‹ã‚‰ ' : '') + 'åˆæµã—ã¾ã™';

    // Uã‚¿ãƒ¼ãƒ³
    case 'turn':
      if (modifier === 'uturn') {
        return 'Uã‚¿ãƒ¼ãƒ³ã—ã¾ã™';
      }
      // é€šå¸¸ã®äº¤å·®ç‚¹ (ä¾‹: å¤©ç¥ã‚’å³æ–¹å‘)
      if (name) {
        return name + ' ã‚’ ' + getDirectionText(modifier) + ' æ–¹å‘ã§ã™';
      }
      // åå‰ãŒãªã„äº¤å·®ç‚¹ (ä¾‹: å·¦ã¸æ›²ãŒã‚‹)
      return getDirectionText(modifier) + ' ã«æ›²ãŒã‚Šã¾ã™';
    
    // ç›´é€²ãƒ»é“ãªã‚Š (äº¤å·®ç‚¹åãŒã‚ã‚‹å ´åˆãªã©)
    case 'new name':
    case 'continue':
      if (modifier === 'uturn') return 'Uã‚¿ãƒ¼ãƒ³ã—ã¾ã™';
      // é“è·¯åãŒå¤‰ã‚ã‚‹å ´åˆï¼ˆä¾‹: ã€‡ã€‡é€šã‚Šã«é€²ã‚€ï¼‰
      if (name && type === 'new name') {
         return name + ' ã«å…¥ã‚Šã¾ã™';
      }
      // äº¤å·®ç‚¹åä»˜ãã®ç›´é€²
      if (modifier === 'straight' && name) {
        return name + ' ã‚’ ç›´é€²ã—ã¾ã™';
      }
      return 'é“ãªã‚Šã«é€²ã‚€';

    case 'roundabout':
      return 'ãƒ­ãƒ¼ã‚¿ãƒªãƒ¼ã«å…¥ã‚Šã¾ã™';
      
    case 'arrive':
      return 'ç›®çš„åœ°ã«åˆ°ç€ã—ã¾ã™';
      
    default:
      // ãã®ä»–ã® "turn" ã‚„ "continue" ã§åå‰ãŒãªã„å ´åˆ
      if (modifier) {
        return getDirectionText(modifier) + ' ã«æ›²ãŒã‚Šã¾ã™';
      }
      return 'é“ãªã‚Šã«é€²ã‚€'; 
  }
}

// modifierã‚’æ—¥æœ¬èªã®ã€Œæ–¹å‘ã€ã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function getDirectionText(modifier) {
  switch (modifier) {
    case 'left': return 'å·¦';
    case 'right': return 'å³';
    case 'slight left': return 'æ–œã‚å·¦';
    case 'slight right': return 'æ–œã‚å³';
    case 'sharp left': return 'å¤§ããå·¦';
    case 'sharp right': return 'å¤§ããå³';
    case 'straight': return 'ç›´é€²';
    case 'uturn': return 'Uã‚¿ãƒ¼ãƒ³';
    default: return 'é“ãªã‚Š';
  }
}

// éŸ³å£°
function speak(text){
Â  if(speech.speaking) speech.cancel();
Â  const u=new SpeechSynthesisUtterance(text);
  u.lang = 'ja-JP'; // è¨€èªã‚’æ—¥æœ¬èªã«æŒ‡å®š
Â  speech.speak(u);
}
</script>
</body>
</html>
