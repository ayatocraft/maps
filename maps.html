<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Leaflet Navigation App</title>
    
    <!-- Leaflet & Tailwind CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- --- CSS --- -->
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Noto Sans JP', sans-serif; }
        
        #map { width: 100%; height: 100%; z-index: 1; }

        /* 現在地マーカー */
        .nav-marker-icon {
            transition: transform 0.25s linear; 
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
            z-index: 1000 !important;
        }
        .nav-marker-icon svg {
            transition: transform 0.25s linear;
            will-change: transform;
        }

        /* 案内バー */
        #nav-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #0F9D58;
            color: white;
            z-index: 1000;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: none;
            flex-direction: column;
        }

        .leaflet-top {
            top: 120px;
            transition: top 0.3s;
        }
        body.navigating .leaflet-top { top: 140px; }

        .leaflet-routing-container { display: none !important; }

        /* サイドバー */
        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 350px;
            background: white;
            z-index: 1001;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            padding: 20px;
            overflow-y: auto;
            transform: translateX(0);
            transition: transform 0.3s ease-in-out;
        }
        @media (max-width: 640px) {
            #sidebar { width: 100%; max-width: 100%; }
        }
        #sidebar.hidden-side { transform: translateX(-100%); }

        /* ボタン無効化時のスタイル */
        button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        /* 現在地ボタン */
        #center-btn {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 900;
            background: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
            font-size: 1.5rem;
            color: #555;
            transition: all 0.2s;
        }
        #center-btn.active { color: #007bff; background-color: #f0f8ff; border: 2px solid #007bff; }
    </style>
</head>
<body>

    <div id="sidebar">
        <h1 class="text-xl font-bold mb-4 flex items-center gap-2">
            <i class="fas fa-location-arrow text-blue-500"></i> ナビゲーション
        </h1>
        
        <div class="mb-4 bg-gray-100 p-3 rounded">
            <label class="block text-sm font-bold mb-1">地図タイプ</label>
            <div class="flex gap-2">
                <button onclick="setLayer('osm')" class="flex-1 py-1 px-2 bg-white border rounded shadow-sm hover:bg-gray-50 text-sm">標準</button>
                <button onclick="setLayer('satellite')" class="flex-1 py-1 px-2 bg-white border rounded shadow-sm hover:bg-gray-50 text-sm">航空写真</button>
            </div>
        </div>

        <div class="space-y-3">
            <div>
                <label class="block text-sm text-gray-600">出発地</label>
                <input type="text" id="start-input" placeholder="現在地 (空白で使用)" class="w-full border p-2 rounded focus:outline-none focus:border-blue-500">
            </div>
            <div>
                <label class="block text-sm text-gray-600">目的地</label>
                <input type="text" id="end-input" placeholder="場所を検索 または 地図をタップ" class="w-full border p-2 rounded focus:outline-none focus:border-blue-500">
            </div>
            
            <div class="flex items-center gap-2">
                <input type="checkbox" id="avoid-highways" class="w-4 h-4">
                <label for="avoid-highways" class="text-sm">高速道路を使わない</label>
            </div>

            <div class="pt-2 grid grid-cols-2 gap-2">
                <button id="btn-nav" onclick="calculateAndStart(false)" class="bg-blue-600 text-white py-3 rounded shadow hover:bg-blue-700 font-bold flex justify-center items-center gap-2">
                    <i class="fas fa-route"></i> <span>ナビ開始</span>
                </button>
                <button id="btn-demo" onclick="calculateAndStart(true)" class="bg-orange-500 text-white py-3 rounded shadow hover:bg-orange-600 font-bold flex justify-center items-center gap-2">
                    <i class="fas fa-play"></i> <span>デモ走行</span>
                </button>
            </div>
            <p class="text-xs text-gray-500 mt-2">※目的地は地図の右クリック(長押し)でも設定できます。<br>※ルートが見つからない場合は場所を変えて試してください。</p>
        </div>
    </div>

    <div id="nav-panel">
        <div class="flex justify-between items-start">
            <div class="flex-1 text-white">
                <div class="flex items-baseline gap-2 mb-1">
                    <span id="nav-turn-icon" class="text-4xl"><i class="fas fa-arrow-up"></i></span>
                    <div>
                        <div id="nav-distance" class="text-3xl font-bold">0 m</div>
                    </div>
                </div>
                <div id="nav-instruction" class="text-lg font-medium leading-tight">案内を開始します</div>
                <div id="nav-total-dist" class="text-sm opacity-80 mt-1">目的地まで: -- km</div>
            </div>

            <button onclick="stopNavigation()" class="ml-4 bg-red-600 text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg hover:bg-red-700 shrink-0">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>

    <div id="map"></div>
    <div id="center-btn" onclick="toggleFollowMode()"><i class="fas fa-crosshairs"></i></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script>
        // --- 設定変数 ---
        const UPDATE_INTERVAL_MS = 250; 
        const DEMO_SPEED_KMH = 150; // デモ走行の速度
        const SNAP_TOLERANCE_METERS = 20; // ルート吸着距離 (m)
        const REROUTE_THRESHOLD_METERS = 40; // リルート判定距離 (m)
        
        let map, navMarker, routingControl = null, currentRoute = null;
        let isNavigating = false, isDemoMode = false, isFollowing = true;
        let demoTimerId = null, watchId = null;
        let myLocation = { lat: 35.681236, lng: 139.767125, heading: 0 };
        let currentRotation = 0, lastSpokenInstruction = "";
        let isFirstRouteCalculation = true; // 初回フラグ
        let isRerouting = false; // リルート処理中フラグ
        let synth = window.speechSynthesis;
        let voices = [];

        // レイヤー
        const layers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' })
        };

        const carIconHtml = `
            <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" style="transform-origin: center;">
                <path d="M20 5 L35 35 L20 28 L5 35 Z" fill="#ff3333" stroke="white" stroke-width="2" />
            </svg>`;
        const carIcon = L.divIcon({ className: 'nav-marker-icon', html: carIconHtml, iconSize: [40, 40], iconAnchor: [20, 20] });
        const endIcon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png', shadowSize: [41, 41] });

        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([myLocation.lat, myLocation.lng], 15);
            layers.osm.addTo(map);
            L.control.zoom({ position: 'topright' }).addTo(map);
            navMarker = L.marker([myLocation.lat, myLocation.lng], { icon: carIcon }).addTo(map);
            startGeolocation();
            
            // 音声ロード
            loadVoices();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoices;
            }

            map.on('contextmenu', function(e) {
                document.getElementById('end-input').value = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
            });
            map.on('dragstart', () => { isFollowing = false; document.getElementById('center-btn').classList.remove('active'); });
        }

        function loadVoices() {
            voices = synth.getVoices();
        }

        function setLayer(type) {
            map.eachLayer(layer => map.removeLayer(layer));
            layers[type].addTo(map);
            if(navMarker) navMarker.addTo(map);
            if(routingControl) routingControl.addTo(map);
        }

        function startGeolocation() {
            if ("geolocation" in navigator) {
                watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        if (isNavigating && isDemoMode) return;
                        const rawLat = position.coords.latitude;
                        const rawLng = position.coords.longitude;
                        const heading = position.coords.heading; 

                        let displayLat = rawLat;
                        let displayLng = rawLng;

                        // ナビ中かつデモ以外なら、ルートとの距離を計算
                        if (isNavigating && !isDemoMode && currentRoute && !isRerouting) {
                            const snap = snapToRoute(rawLat, rawLng, currentRoute.coordinates);
                            
                            if (snap.dist <= SNAP_TOLERANCE_METERS) {
                                // 20m以内ならルート上に吸着
                                displayLat = snap.lat;
                                displayLng = snap.lng;
                            } else if (snap.dist > REROUTE_THRESHOLD_METERS) {
                                // 40m以上離れたらリルート実行
                                triggerReroute(rawLat, rawLng);
                            }
                        }

                        updateMyLocation(displayLat, displayLng, heading);
                    },
                    (error) => { console.warn("GPS Error:", error); },
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
                );
            }
        }

        // リルート実行関数
        function triggerReroute(lat, lng) {
            if (isRerouting) return;
            isRerouting = true;
            console.log("Rerouting triggered...");
            speak("ルートを外れました。再検索します。");

            const endWp = routingControl.getWaypoints()[1]; // 現在の目的地
            
            // 現在地から目的地へ再検索
            routingControl.setWaypoints([
                L.latLng(lat, lng),
                endWp.latLng
            ]);

            setTimeout(() => { isRerouting = false; }, 3000);
        }

        // ルート上の最も近い点を計算する関数
        function snapToRoute(lat, lng, coords) {
            let minDist = Infinity;
            let closestPt = { lat: lat, lng: lng };
            const p = L.latLng(lat, lng);

            for (let i = 0; i < coords.length - 1; i++) {
                const p1 = L.latLng(coords[i]);
                const p2 = L.latLng(coords[i+1]);
                const closestOnSeg = getClosestPointOnSegment(p, p1, p2);
                const dist = map.distance(p, closestOnSeg);
                
                if (dist < minDist) {
                    minDist = dist;
                    closestPt = closestOnSeg;
                }
            }
            return { lat: closestPt.lat, lng: closestPt.lng, dist: minDist };
        }

        function getClosestPointOnSegment(p, p1, p2) {
            const x = p1.lat, y = p1.lng;
            const dx = p2.lat - x, dy = p2.lng - y;
            const dot = dx * dx + dy * dy;
            let t;
            if (dot > 0) {
                t = ((p.lat - x) * dx + (p.lng - y) * dy) / dot;
            } else {
                t = 0;
            }
            if (t > 1) t = 1;
            else if (t < 0) t = 0;
            return L.latLng(x + t * dx, y + t * dy);
        }

        function updateMyLocation(lat, lng, heading) {
            myLocation.lat = lat; myLocation.lng = lng;
            navMarker.setLatLng([lat, lng]);
            if (heading !== null && heading !== undefined && !isNaN(heading)) {
                myLocation.heading = heading;
                let target = heading % 360;
                let currentMod = currentRotation % 360;
                if (currentMod < 0) currentMod += 360; 
                let diff = target - currentMod;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                currentRotation += diff;
                const iconEl = navMarker.getElement();
                if (iconEl) {
                    const svg = iconEl.querySelector('svg');
                    if (svg) svg.style.transform = `rotate(${currentRotation}deg)`;
                }
            }
            if (isFollowing) map.setView([lat, lng], map.getZoom(), { animate: true, duration: 0.25 });
			
			 // ====== ★ ここから追加（案内更新の核心） ======
    if (isNavigating && !isDemoMode && currentRoute) {
        const coordIdx = getNearestRouteIndex(lat, lng, currentRoute.coordinates);
        const instrIdx = getInstructionIndexFromCoord(currentRoute, coordIdx);
        updateNavDisplay(instrIdx);

        const instr = currentRoute.instructions[instrIdx];
        if (instr && instr.distance < 120) {
            const key = `${instrIdx}_${Math.floor(instr.distance / 10)}`;
            if (lastSpokenInstruction !== key) {
                speak(`まもなく、${getTurnText(instr.modifier, instr.type, instr.text)}です`);
                lastSpokenInstruction = key;
            }
        }
    }
        }

        function toggleFollowMode() {
            isFollowing = true; 
            document.getElementById('center-btn').classList.add('active');
            map.setView(navMarker.getLatLng(), map.getZoom(), {animate: true});
        }

        // --- 音声関連の強化 ---
        function unlockAudio() {
            // モバイルでのブロック解除のため、実際に何か喋らせる
            speak("ナビゲーションを開始します");
        }

        function speak(text) {
            if (!synth) return;
            
            // 連続して呼ばれた場合、前のをキャンセルして即座に新しいのを喋る
            synth.cancel();

            const uttr = new SpeechSynthesisUtterance(text);
            uttr.lang = 'ja-JP';
            uttr.rate = 1.0;
            uttr.volume = 1.0;

            // 日本語ボイスを優先的に探して適用
            if (voices.length > 0) {
                const jaVoice = voices.find(v => v.lang.includes('ja') || v.lang.includes('JP'));
                if (jaVoice) uttr.voice = jaVoice;
            }

            synth.speak(uttr);
        }

        async function calculateAndStart(demo) {
            unlockAudio(); // 音声アンロック実行

            const startInput = document.getElementById('start-input').value;
            const endInput = document.getElementById('end-input').value;
            const avoidHighways = document.getElementById('avoid-highways').checked;
            
            if (!endInput) { alert("目的地を入力してください"); return; }
            
            setLoading(true);

            let startLatLng = L.latLng(myLocation.lat, myLocation.lng);
            if (startInput && startInput.includes(',')) {
                const p = startInput.split(',');
                startLatLng = L.latLng(parseFloat(p[0]), parseFloat(p[1]));
            }

            try {
                let endLatLng = null;
                if (endInput.includes(',')) {
                    const p = endInput.split(',');
                    endLatLng = L.latLng(parseFloat(p[0]), parseFloat(p[1]));
                    startRouteEngine(startLatLng, endLatLng, avoidHighways, demo);
                } else {
                    const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(endInput)}&accept-language=ja`);
                    const data = await res.json();
                    
                    if (data && data.length > 0) {
                        endLatLng = L.latLng(data[0].lat, data[0].lon);
                        startRouteEngine(startLatLng, endLatLng, avoidHighways, demo);
                    } else { 
                        alert("場所が見つかりませんでした。地名を変えるか、地図を右クリックして目的地を設定してください。"); 
                        setLoading(false);
                    }
                }
            } catch (e) {
                console.error(e);
                alert("検索中にエラーが発生しました。通信環境を確認してください。");
                setLoading(false);
            }
        }

        function setLoading(isLoading) {
            const btnNav = document.getElementById('btn-nav');
            const btnDemo = document.getElementById('btn-demo');
            if (isLoading) {
                btnNav.disabled = true;
                btnDemo.disabled = true;
                btnNav.querySelector('span').textContent = "検索中...";
                btnDemo.querySelector('span').textContent = "検索中...";
            } else {
                btnNav.disabled = false;
                btnDemo.disabled = false;
                btnNav.querySelector('span').textContent = "ナビ開始";
                btnDemo.querySelector('span').textContent = "デモ走行";
            }
        }

        function startRouteEngine(start, end, avoidHighways, demo) {
            if (routingControl) { map.removeControl(routingControl); routingControl = null; }

            setLoading(false);
            isDemoMode = demo;
            isNavigating = true;
            isFirstRouteCalculation = true;
            isRerouting = false;

            document.getElementById('sidebar').classList.add('hidden-side');
            document.getElementById('nav-panel').style.display = 'flex';
            document.body.classList.add('navigating');

            const routerOptions = {
                waypoints: [start, end],
                router: L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                    profile: 'driving',
                    routingOptions: { 
                        exclude: avoidHighways ? ['motorway'] : [], 
                        steps: true,
                        overview: 'full',
                        geometries: 'geojson'
                    }
                }),
                lineOptions: { styles: [{color: '#4285F4', opacity: 0.8, weight: 8}] },
                createMarker: function(i, wp) {
                    if (i === 0) return null;
                    return L.marker(wp.latLng, {icon: endIcon});
                },
                addWaypoints: false, 
                fitSelectedRoutes: false, 
                showAlternatives: false
            };

            routingControl = L.Routing.control(routerOptions).addTo(map);

            routingControl.on('routesfound', function(e) {
                currentRoute = e.routes[0];
                updateNavDisplay(0);

                if (isFirstRouteCalculation) {
                    const bounds = L.latLngBounds(currentRoute.coordinates);
                    map.fitBounds(bounds, {padding: [50, 50]});
                    isFirstRouteCalculation = false;
                }

                if (isDemoMode) {
                    const processedRoute = preprocessRoute(currentRoute);
                    startDemoTimer(processedRoute);
                }
            });

            routingControl.on('routingerror', function(e) {
                console.error("OSRM Error:", e);
                if(isRerouting) {
                    isRerouting = false;
                    return; 
                }
                let msg = "ルートが見つかりませんでした。";
                if (e.error && e.error.message) msg += ` (${e.error.message})`;
                
                alert(msg);
                stopNavigation();
            });
        }

        function stopNavigation() {
            isNavigating = false;
            isDemoMode = false;
            if (demoTimerId) clearInterval(demoTimerId);
            if (routingControl) { map.removeControl(routingControl); routingControl = null; }
            currentRoute = null;

            document.getElementById('sidebar').classList.remove('hidden-side');
            document.getElementById('nav-panel').style.display = 'none';
            document.body.classList.remove('navigating');
            
            map.setView([myLocation.lat, myLocation.lng], 15);
            isFollowing = true;
            document.getElementById('center-btn').classList.add('active');
            setLoading(false);
        }

        // --- デモ・案内ロジック ---
        function preprocessRoute(route) {
            const coords = route.coordinates;
            const dists = [0]; 
            let totalDist = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                totalDist += map.distance(coords[i], coords[i+1]);
                dists.push(totalDist);
            }
            const speedMperMs = DEMO_SPEED_KMH / 3.6 / 1000; 
            const totalDurationMs = totalDist / speedMperMs;
            return { coords: coords, dists: dists, totalDist: totalDist, totalDurationMs: totalDurationMs, instructions: route.instructions };
        }

        function startDemoTimer(data) {
            const startTime = Date.now();
            demoTimerId = setInterval(() => {
                if (!isNavigating || !isDemoMode) { clearInterval(demoTimerId); return; }
                const elapsed = Date.now() - startTime;
                if (elapsed >= data.totalDurationMs) {
                    clearInterval(demoTimerId);
                    speak("目的地に到着しました");
                    stopNavigation();
                    return;
                }
                const speedMperMs = DEMO_SPEED_KMH / 3.6 / 1000;
                const currentDist = elapsed * speedMperMs;
                let idx = 0;
                for (let i = 0; i < data.dists.length - 1; i++) {
                    if (currentDist >= data.dists[i] && currentDist < data.dists[i+1]) { idx = i; break; }
                }
                const p1 = data.coords[idx];
                const p2 = data.coords[idx+1];
                const distStart = data.dists[idx];
                const distEnd = data.dists[idx+1];
                const ratio = (currentDist - distStart) / ((distEnd - distStart) || 1);
                const lat = p1.lat + (p2.lat - p1.lat) * ratio;
                const lng = p1.lng + (p2.lng - p1.lng) * ratio;
                const heading = calculateHeading(p1.lat, p1.lng, p2.lat, p2.lng);
                updateMyLocation(lat, lng, heading);
                updateDemoNav(data, idx, currentDist);
            }, UPDATE_INTERVAL_MS);
        }

        function updateDemoNav(data, coordIdx, currentTotalDist) {
            let currentInstrIdx = 0;
            const instrs = data.instructions;
            for (let k = instrs.length - 1; k >= 0; k--) {
                if (instrs[k].index <= coordIdx) { currentInstrIdx = k; break; }
            }
            const nextInstrIdx = currentInstrIdx + 1;
            if (nextInstrIdx < instrs.length) {
                const nextTurnCoordIdx = instrs[nextInstrIdx].index;
                const nextTurnDist = data.dists[nextTurnCoordIdx];
                const distToTurn = Math.max(0, nextTurnDist - currentTotalDist);
                const nextInstr = instrs[nextInstrIdx];
                const text = getTurnText(nextInstr.modifier, nextInstr.type, nextInstr.text);
                
                document.getElementById('nav-instruction').textContent = text;
                document.getElementById('nav-turn-icon').innerHTML = `<i class="fas ${getTurnIcon(nextInstr.modifier)}"></i>`;
                document.getElementById('nav-distance').textContent = formatDistance(distToTurn);

                const key = `idx_${nextInstrIdx}_dist_${Math.floor(distToTurn/100)}`; 
                if ((distToTurn < 310 && distToTurn > 290) || (distToTurn < 110 && distToTurn > 90)) {
                      if (lastSpokenInstruction !== key) {
                           speak(`およそ${formatDistance(distToTurn)}先、${text}です`);
                           lastSpokenInstruction = key;
                      }
                }
            }
        }

        // --- ナビ案内ロジック ---
function calcDistanceToNextTurn(route, coordIdx, instrIdx) {
    const coords = route.coordinates;
    const instrs = route.instructions;

    if (!coords || !instrs) return 0;
    if (instrIdx + 1 >= instrs.length) return 0;
    if (coordIdx < 0 || coordIdx >= coords.length - 1) return 0;

    const targetIdx = instrs[instrIdx + 1].index;
    if (targetIdx <= coordIdx) return 0;

    let dist = 0;
    const end = Math.min(targetIdx, coords.length - 1);

    for (let i = coordIdx; i < end; i++) {
        const a = coords[i];
        const b = coords[i + 1];
        if (!a || !b) continue;

        dist += map.distance(a, b);
    }

    return dist;
}

        // --- ユーティリティ ---
        function calculateHeading(lat1, lng1, lat2, lng2) {
            const radLat1 = lat1 * Math.PI / 180;
            const radLat2 = lat2 * Math.PI / 180;
            const diffLng = (lng2 - lng1) * Math.PI / 180;
            const y = Math.sin(diffLng) * Math.cos(radLat2);
            const x = Math.cos(radLat1) * Math.sin(radLat2) - Math.sin(radLat1) * Math.cos(radLat2) * Math.cos(diffLng);
            let brng = Math.atan2(y, x) * 180 / Math.PI;
            return (brng + 360) % 360;
        }
		function calcDistanceToNextTurn(route, coordIdx, instrIdx) {
    const coords = route.coordinates;
    const instr = route.instructions[instrIdx + 1];
    if (!instr) return 0;

    let dist = 0;
    for (let i = coordIdx; i < instr.index; i++) {
        dist += map.distance(coords[i], coords[i + 1]);
    }
    return dist;
}
		// 現在位置がルートのどの座標インデックス付近かを求める
function getNearestRouteIndex(lat, lng, coords) {
    let minDist = Infinity;
    let idx = 0;
    const p = L.latLng(lat, lng);

    for (let i = 0; i < coords.length; i++) {
        const d = map.distance(p, coords[i]);
        if (d < minDist) {
            minDist = d;
            idx = i;
        }
    }
    return idx;
}

// 座標インデックスから instruction index を取得
function getInstructionIndexFromCoord(route, coordIdx) {
    const instrs = route.instructions;
    let result = 0;
    for (let i = 0; i < instrs.length; i++) {
        if (instrs[i].index <= coordIdx) {
            result = i;
        } else {
            break;
        }
    }
    return result;
}


        function formatDistance(m) {
            if (m >= 1000) return (m / 1000).toFixed(1) + " km";
            return (Math.round(m / 10) * 10) + " m";
        }

        function getTurnText(modifier, type, name) {
            const mod = (modifier || "").toLowerCase().trim();
            const tp = (type || "").toLowerCase().trim();
            const nm = (name || "").trim();
            const dirs = {
                'left': '左方向', 'right': '右方向', 'sharp left': '大きく左', 'sharp right': '大きく右',
                'slight left': '斜め左', 'slight right': '斜め右', 'straight': '直進', 'uturn': 'Uターン'
            };
            let text = "";
            if (dirs[mod]) text = dirs[mod] + "へ";
            if (tp === 'depart') return "出発";
            else if (tp === 'arrive') return "目的地周辺";
            else if (tp === 'roundabout' || tp === 'rotary') text = "ロータリーを" + (dirs[mod] || "回って");
            else if (tp === 'fork') text = "分岐を" + (dirs[mod] || "道なり");
            else if (tp === 'merge') text = "合流を" + (dirs[mod] || "道なり");
            else if (tp === 'on ramp') text = "高速入口";
            else if (tp === 'off ramp') text = "高速出口";
            else if (tp === 'end of road') text = "突き当たりを" + (dirs[mod] || "");
            else if (tp === 'new name' || tp === 'continue') text = "道なり";
            else if (text === "") text = "道なり";
            else text += "曲がる";
            if (nm && nm !== "") {
                if (text.includes("曲がる") || text.includes("へ")) {
                    const dir = dirs[mod] || mod;
                    text = `${nm}を${dir}`; 
                } else if (text === "道なり") text = `${nm}方面へ`;
                else text += ` (${nm})`;
            }
            return text;
        }

        function getTurnIcon(mod) {
            const m = (mod || "").toLowerCase().trim();
            const map = {
                'left': 'fa-arrow-left', 'right': 'fa-arrow-right', 'sharp left': 'fa-reply', 'sharp right': 'fa-share',
                'slight left': 'fa-arrow-circle-left', 'slight right': 'fa-arrow-circle-right', 'straight': 'fa-arrow-up',
                'uturn': 'fa-rotate-left', 'fork': 'fa-code-branch', 'merge': 'fa-code-branch', 'roundabout': 'fa-sync'
            };
            return map[m] || 'fa-arrow-up';
        }

        window.onload = initMap;
    </script>
</body>
</html>
